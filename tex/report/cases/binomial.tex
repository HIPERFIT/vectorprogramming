\section{The binomial option pricing model}
\label{sec:binomial-model}
A relatively simple discrete time model for computing the price of an
American style option is the \emph{standard binomial model}
\cite{cox1979option}. The model is widely used in the financial
industry \cite{ganesan2009acceleration}, and is thus a relevant case
for our investigation.

The basic assumption is that the price of the underlying follows a
binomial process over equally spaced time steps. This makes it
possible to write out the possible future states of the
underlying. Moving a single time step forward, the binomial process
produces two possible future states of the underlying. The value of
the underlying can go either up or down with probabilities $q$ and $1
- q$ respectively. We denote the rate of up and down movement as $u$
and $d$ respectively. The change over one period $\Delta t$ is thus
given as:

$$S(t+\Delta t) = \left\{
  \begin{array}{ll}
    S(t)u & \quad \text{with probability $q$} \\
    S(t)d & \quad \text{with probability $1-q$}
  \end{array} \right.
$$

We skip the discussion of how to compute the constants $q$, $u$ and
$d$ and refer to the paper by Cox, Ross and Rubinstein that introduced
the model \cite{cox1979option}. After several time steps the binomial
process will unfold into a lattice of possible futures states as shown
in Figure \ref{fig:binomial-tree}. In this example we have assumed
that $u$ and $d$ has been selected such that $u\cdot d = 1$, but that
is not a necessity.

\begin{figure}
  \centering
  \tikzstyle{nodestyle} = [text centered, minimum size=0.42cm, inner sep=0]

\begin{tikzpicture}
  \node at (0,0) [nodestyle] (S1) {$S(t_0)$};

  \node at (-1, -1) [nodestyle] (dS) {$dS(t_0)$};
  \node at ( 1, -1) [nodestyle] (uS) {$uS(t_0)$};

  \node at ( 2, -2) [nodestyle] (u2S) {$u^2S(t_0)$};
  \node at ( 0, -2) [nodestyle] (S2) {$S(t_0)$};
  \node at (-2, -2) [nodestyle] (d2S) {$d^2S(t_0)$};

  \node at ( 3, -3) [nodestyle] (u3S) {$u^3S(t_0)$};
  \node at ( 1, -3) [nodestyle] (uS2) {$uS(t_0)$};
  \node at (-1, -3) [nodestyle] (dS2) {$dS(t_0)$};
  \node at (-3, -3) [nodestyle] (d3S) {$d^3S(t_0)$};

  \node at (-4.5,  0) [] (t0) {$S(t_0) =$};
  \node at (-4.5, -1) [] (t0) {$S(t_1) =$};
  \node at (-4.5, -2) [] (t0) {$S(t_2) =$};
  \node at (-4.5, -3) [] (t0) {$S(t_3) =$};

  \path[-latex]
     (S1) edge (uS)
     (S1) edge (dS)

     (uS) edge (S2)
     (dS) edge (S2)
     (uS) edge (u2S)
     (dS) edge (d2S)

     (u2S) edge (u3S)
     (u2S) edge (uS2)
     (S2)  edge (uS2)
     (S2)  edge (dS2)
     (d2S) edge (dS2)
     (d2S) edge (d3S);
\end{tikzpicture}

\vspace{2mm}

\caption{Lattice generated by the binomial process of a single
  underlying over three periods ($T=t_3$). The root
  node represents the current price of the underlying and the leafs
  represents possible values at expiration time.}
\label{fig:binomial-tree}
\end{figure}

Each layer in the tree corresponds to a time step $t$, and the nodes
of the layer are the different possible prices $S(t)$ of the
underlying. To distinguish between the nodes on a single layer we
attach a unique index $i$ to each node of the tree and define
$\mathsf{left\textsf{-}child}(i)$ and
$\mathsf{right\textsf{-}child}(i)$ to navigate the indices of the
tree. We use the notation $S_i(t)$ to refer to the particular node $i$
at layer $t$.

The final row represents the possible values of the underlying at
expiration time, $T$. We can use the same procedure as for European
options (discussed in Example \ref{example:europeancall} above) to
find the value of our option at each of these possible cases. Thus,
for each possible $S_i(T)$, that is, for each leaf node, we compute
the option value as either $V_i(T) = max(S_i(T)-K, 0)$ for call
options or $V_i(T) = max(K-S_i(T),0)$ for put options, where $K$ is
the strike price.

The algorithm now proceeds by estimating the price $V_i$ of the option
in the remaining lattice points, by iterating backwards (towards the
root). The price estimate at each lattice point for time $t$ depends
only on its two children at time $t+1$, which prices was calculated in
the previous iteration. This is done by recursively discounting:
$$V_{i} = e^{-r\Delta t} \cdot (q\cdot V_{\mathsf{left\textsf{-}child}(i)} + (1-q)\cdot V_{\mathsf{right\textsf{-}child}(i)})$$
where the probability $q$ is used to attain the expected value from
either of the two alternative futures, and $e^{r\Delta t}$ is the
guaranteed scale of increment over a single time period $\Delta t$ for
a riskless investment with interest rate $r$.

% \todo{Display the full binomial algorithm and parameters in a concise fact-box
% like format. Be sure to explain what $S(i,t)$ is.}

% In equations, this may be written as follows, where $x_{i,t}$ represents a
% lattice point.

% \begin{align*}
% v(x_{i,t}) &= h(f_{i,t}(v(x_{i,t+1})),g_{i,t}(v(x_{i+1,t+1}))) \\
% v(x_{i,T}) &= \max\{ 0, k - S(i,T) \} \tag{for a put-option}\\
% v(x_{i,T}) &= \max\{ 0, S(i,T) - k \} \tag{for a call-option}\\
% \end{align*}

% In our case the functions $f_{i,t},g_{i,t},h$ contain only simple constant-time
% arithmetic calculation.

\subsection{Implementation Techniques}
As seen above, the value of $V_i(t)$ depends only on values associated
with time $t+1$. Therefore, for each $t$, the evaluation of $V_i(t)$'s may
proceed in parallel.

Algorithm \ref{alg:binomial-algorithm} illustrates this in pseudocode
that uses only two arrays in tandem to hold the intermediately
produced values. It should also be observed that it is not necessary
to build the complete lattice, as we are only interested in the values
at expiration date.

\begin{algorithm}
% \begin{verbatim}
% binom:
%   -- A,B are assumed preallocated, and T is assumed odd.
%   t <- T
%   B <- parmap (\i -> max 0 (k-S(i,T))) [0..T]
%   while t > 0
%     A <- parmap (\i -> h(f_{i,t}(B[i]),g_{i,t}(B[i+1))) [0..t]
%     t <- t -1
%     B <- parmap (\i -> h(f_{i,t}(A[i]),g_{i,t}(A[i+1))) [0..t]
%     t <- t -1
%   return B
% \end{verbatim}

\begin{algorithmic}
\Function{Binom}{$\Delta t$, $T$, $u$, $d$, $q$, $S(0)$, $K$, $r$}
  % \State $A \gets \mathbf{alloc}\ T$
  % \State $B \gets \mathbf{alloc}\ T$
  \State $S(T) \gets \mathbf{parmap}$ $(\lambda i.\ d^{T-i}u^{i}S(0))$ $\{0..T\}$ \Comment Value at expiration
  \State $B \gets \mathbf{parmap}$ $(\lambda S_i(T).\ \mathsf{max}\ 0\ (K-S_i(T)))$ $S(T)$ \Comment Perform exercise decision
  \State $t \gets T$
  \While{$t > 0$}
    \State $A \gets \mathbf{parmap}$ $(\lambda i.\ e^{-r\Delta t} \cdot (qB[i] + (1-q)B[i+1]))$ $\{0..t\}$
    \State $t \gets t-1$
    \State $B \gets \mathbf{parmap}$ $(\lambda i.\ e^{-r\Delta t} \cdot (qA[i] + (1-q)A[i+1]))$ $\{0..t\}$
    \State $t \gets t-1$
  \EndWhile
  \State \Return $B[0]$
\EndFunction
\end{algorithmic}

  \caption{Binomial algorithm}
  \label{alg:binomial-algorithm}
\end{algorithm}

As defined by Blelloch \cite{blelloch1996programming}, the above code
may be reasonably assumed to have time complexities $Work(T^2/2)$ and
$Depth(T)$, and memory complexity $O(2T)$.

While the above code is both short and simple in structure, the main motive for
pursuing parallelism is in gaining performance rather than expressivity.  To
explore further algorithm samples, we examine the binomial pricing algorithm
included in the CUDA SDK \cite{CUDAbinomial}, depicted in Algorithm
\ref{alg:cuda-binom}. Here the \textsc{Partition}$(i,n,k,o)$ procedure
partitions the index range $[i,n]$ into $k$ sized chunks with $o$ indices
overlapping. Here it is written as a separate procedure for clarity, but in the
actual code the partitioning logic is fused into the index computations of the
\texttt{for}-loop.

\begin{algorithm}
\begin{algorithmic}
  \Function{GPUBinom}{$mem$, $\Delta_{mem}$, $\Delta t$, $T$, $u$, $d$, $q$, $S(0)$, $K$, $r$}
  \State $S(T) \gets \mathbf{parmap}$ $(\lambda i.\ d^{T-i}u^{i}S(0))$ $\{0..T\}$ \Comment Value at expiration
  \State $B \gets \mathbf{parmap}$ $(\lambda S_i(T).\ \mathsf{max}\ 0\ (K-S_i(T)))$ $S(T)$ \Comment in global memory
  \State $t \gets T$
  \While{$t > 0$}
    \For{each $(i,j)$ of \Call{Partition}{$0$,$t$, $mem$, $\Delta_{mem}$}}
      \State $C \gets B[i:j] $ \Comment Copy to shared memory
      \State $C \gets$ $\Delta_{mem}$ iterations of the body of \Call{Binom}{}
      \State $B[i:j-\Delta_{mem}] \gets C[0:j-i-\Delta_{mem}] $ \Comment Update global memory
    \EndFor
    \State $t \gets t -\Delta_{mem}$ \Comment All of $B$ now corresponds to $t -\Delta_{mem}$
  \EndWhile
\EndFunction

\Function{Partition}{$i$, $n$, $k$, $o$}
\If{$i+k > n$}
\State\Return $[(i,n)]$
\Else
\State
\Return $(i,i+k)$ : \Call{Partition}{$i+k-o+1$, $n$, $k$, $o$}
\EndIf
\EndFunction
\end{algorithmic}
\caption{Binomial portfolio pricer}
\label{alg:cuda-binom}
\end{algorithm}

This algorithm explicitly divides the pricing problem into packages that fit
exactly into the amount of shared memory availabe for a Streaming
Multiprocessor. This includes a configurable amount of duplicated computation
for each iteration, because it is faster to recompute some part of the solution
if doing so brings down the number of accesses to global devce memory. Thus,
the optimal value of $\Delta_{mem}$ is hardware specific.  Algorithm
\ref{alg:cuda-binom} is only capable of employing $mem$ threads at a time.
Therefore, to scale it must be applied to an entire portforlio of options.  In
the CUDA SDK source code, this is done by doing a kernel call with a CUDA block
for each option to be priced. That way, each option pricing instance gets its
own streaming multiprocessor, and no penalty has to be paid for divergence when
the options in the portfolio vary in size.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../master"
%%% End:
