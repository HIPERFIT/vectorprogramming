\section{The binomial option pricing model}
A relatively simple discrete time model for computing the price of an
American style option is the \emph{standard binomial model}
\cite{cox1979option}. The model is widely used in the financial
industry \cite{ganesan2009acceleration}, and is thus a relevant case
for our investigation.

The basic assumption is that the price of the underlying follows a
binomial process over equally spaced time steps. This makes it
possible to write out the possible future states of the
underlying. Moving a single time step forward, the binomial process
produces two possible future states of the underlying. The value of
the underlying can go either up or down with probabilities $q$ and $1
- q$ respectively. We denote the rate of up and down movement as $u$
and $d$ respectively. The change over one period $\Delta t$ is thus
given as:

$$S(t+\Delta t) = \left\{
  \begin{array}{ll}
    S(t)u & \quad \text{with probability $q$} \\
    S(t)d & \quad \text{with probability $1-q$}
  \end{array} \right.
$$

We skip the discussion of how to compute the constants $q$, $u$ and
$d$ and refer to the paper by Cox, Ross and Rubinstein that introduced
the model \cite{cox1979option}. After several time steps the binomial
process will unfold into a lattice of possible futures states as shown
in Figure \ref{fig:binomial-tree}. In this example we have assumed
that $u$ and $d$ has been selected such that $u\cdot d = 1$, but that
is not a necessity.

\begin{figure}
  \centering
  \tikzstyle{nodestyle} = [text centered, minimum size=0.42cm, inner sep=0]

\begin{tikzpicture}
  \node at (0,0) [nodestyle] (S1) {$S(t_0)$};

  \node at (-1, -1) [nodestyle] (dS) {$dS(t_0)$};
  \node at ( 1, -1) [nodestyle] (uS) {$uS(t_0)$};

  \node at ( 2, -2) [nodestyle] (u2S) {$u^2S(t_0)$};
  \node at ( 0, -2) [nodestyle] (S2) {$S(t_0)$};
  \node at (-2, -2) [nodestyle] (d2S) {$d^2S(t_0)$};

  \node at ( 3, -3) [nodestyle] (u3S) {$u^3S(t_0)$};
  \node at ( 1, -3) [nodestyle] (uS2) {$uS(t_0)$};
  \node at (-1, -3) [nodestyle] (dS2) {$dS(t_0)$};
  \node at (-3, -3) [nodestyle] (d3S) {$d^3S(t_0)$};

  \node at (-4.5,  0) [] (t0) {$S(t_0) =$};
  \node at (-4.5, -1) [] (t0) {$S(t_1) =$};
  \node at (-4.5, -2) [] (t0) {$S(t_2) =$};
  \node at (-4.5, -3) [] (t0) {$S(t_3) =$};

  \path[-latex] 
     (S1) edge (uS)
     (S1) edge (dS)

     (uS) edge (S2)
     (dS) edge (S2)
     (uS) edge (u2S)
     (dS) edge (d2S)

     (u2S) edge (u3S)
     (u2S) edge (uS2)
     (S2)  edge (uS2)
     (S2)  edge (dS2)
     (d2S) edge (dS2)
     (d2S) edge (d3S);
\end{tikzpicture}

\vspace{2mm}

\caption{Lattice generated by the binomial process of a single
  underlying over three periods ($T=t_3$). The root
  node represents the current price of the underlying and the leafs
  represents possible values at expiration time.}
\label{fig:binomial-tree}
\end{figure}

Each layer in the tree corresponds to a time step $t$, and the nodes
of the layer are the different possible prices $S(t)$ of the
underlying. To distinguish between the nodes on a single layer we
attach a unique index $i$ to each node of the tree and define
$\mathsf{left\textsf{-}child}(i)$ and
$\mathsf{right\textsf{-}child}(i)$ to navigate the indices of the
tree. We use the notation $S_i(t)$ to refer to the particular node $i$
at layer $t$.

The final row represents the possible values of the underlying at
expiration time, $T$. We can use the same procedure as for European
options (discussed in Example \ref{example:europeancall} above) to
find the value of our option at each of these possible cases. Thus,
for each possible $S_i(T)$, that is, for each leaf node, we compute
the option value as either $V_i(T) = max(S_i(T)-K, 0)$ for call
options or $V_i(T) = max(K-S_i(T),0)$ for put options, where $K$ is
the strike price.

The algorithm now proceeds by estimating the price $V_i$ of the option
in the remaining lattice points, by iterating backwards (towards the
root). The price estimate at each lattice point for time $t$ depends
only on its two children at time $t+1$, which prices was calculated in
the previous iteration. This is done by recursively discounting:
$$V_{i} = e^{-r\Delta t} \cdot (q\cdot V_{\mathsf{left\textsf{-}child}(i)} + (1-q)\cdot V_{\mathsf{right\textsf{-}child}(i)})$$
where the probability $q$ is used to attain the expected value from
either of the two alternative futures, and $e^{r\Delta t}$ is the
guaranteed scale of increment over a single time period $\Delta t$ for
a riskless investment with interest rate $r$.

% \todo{Display the full binomial algorithm and parameters in a concise fact-box
% like format. Be sure to explain what $S(i,t)$ is.}

% In equations, this may be written as follows, where $x_{i,t}$ represents a
% lattice point.

% \begin{align*}
% v(x_{i,t}) &= h(f_{i,t}(v(x_{i,t+1})),g_{i,t}(v(x_{i+1,t+1}))) \\
% v(x_{i,T}) &= \max\{ 0, k - S(i,T) \} \tag{for a put-option}\\
% v(x_{i,T}) &= \max\{ 0, S(i,T) - k \} \tag{for a call-option}\\
% \end{align*}

% In our case the functions $f_{i,t},g_{i,t},h$ contain only simple constant-time
% arithmetic calculation.

\subsection{Implementation Techniques}
As seen above, the value of $V_i(t)$ depends only on values associated
with time $t+1$. Therefore, for each $t$, the evaluation of $V_i(t)$'s may
proceed in parallel.

Algorithm \ref{alg:binomial-algorithm} illustrates this in pseudocode
that uses only two arrays in tandem to hold the intermediately
produced values. It should also be observed that it is not necessary
to build the complete lattice, as we are only interested in the values
at expiration date.

\begin{algorithm}
% \begin{verbatim}
% binom:
%   -- A,B are assumed preallocated, and T is assumed odd.
%   t <- T
%   B <- parmap (\i -> max 0 (k-S(i,T))) [0..T]
%   while t > 0
%     A <- parmap (\i -> h(f_{i,t}(B[i]),g_{i,t}(B[i+1))) [0..t]
%     t <- t -1
%     B <- parmap (\i -> h(f_{i,t}(A[i]),g_{i,t}(A[i+1))) [0..t]
%     t <- t -1
%   return B
% \end{verbatim}

\begin{algorithmic}
\Function{Binom}{$\Delta t$, $T$, $u$, $d$, $q$, $S(0)$, $K$, $r$}
  % \State $A \gets \mathbf{alloc}\ T$
  % \State $B \gets \mathbf{alloc}\ T$
  \State $S(T) \gets \mathbf{parmap}$ $(\lambda i.\ d^{T-i}u^{i}S(0))$ $\{0..T\}$ \Comment Value at expiration
  \State $B \gets \mathbf{parmap}$ $(\lambda S_i(T).\ \mathsf{max}\ 0\ (K-S_i(T)))$ $S(T)$ \Comment Perform exercise decision
  \State $t \gets T$
  \While{$t > 0$}
    \State $A \gets \mathbf{parmap}$ $(\lambda i.\ e^{-r\Delta t} \cdot (qB[i] + (1-q)B[i+1]))$ $\{0..t\}$
    \State $t \gets t-1$
    \State $B \gets \mathbf{parmap}$ $(\lambda i.\ e^{-r\Delta t} \cdot (qA[i] + (1-q)A[i+1]))$ $\{0..t\}$
    \State $t \gets t-1$
  \EndWhile
  \State \Return $B[0]$
\EndFunction
\end{algorithmic}
  
  \caption{Binomial algorithm}
  \label{alg:binomial-algorithm}
\end{algorithm}

As defined by Blelloch \cite{blelloch1996programming}, the above code
may be reasonably assumed to have time complexities $Work(T^2/2)$ and
$Depth(T)$, and memory complexity $O(2T)$.

While the above code is both short and simple in structure, the main motive for
pursuing parallelism is in gaining performance rather than expressivity.  To
explore further algorithm samples, we examine the binomial pricing algorithm
included in the CUDA SDK \cite{CUDAbinomial}.

\begin{verbatim}
lots of pseudocode.
\end{verbatim}

Notes: Duplication of computation, fixed amount of parallelism pr option being
priced, better scaling to pricing a larger number of options. Remark on the
poor scaling of the first algorithm.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../master"
%%% End:
