\section{Nikola Frontend Architecture}

\todo{Describe how the programming interface with nikola is intended to be
used, i.e. Exp, Array, storable vectors, monad P, compilation from user
perspective, TH same-module restriction...}

The Nikola language is made up of three data types: \texttt{Exp t a},
\texttt{Array r sh a} and the program monad \texttt{P a}. These parts are all
backend agnostic. It also provides a type class directed \texttt{compile}
function for compiling Nikola functions to CUDA code which is subsequently
wrapped as regular haskell functions.

\paragraph{Nikola scalar expressions} are represented by the \texttt{Exp t a} type, with
the phantom type variable \texttt{t} representing the target architecture for
the expression, eg.  \texttt{CUDA}. Thus, it is possible to have Nikola terms
specialised for different backends. This is unusual, as programming languages
are typically assumed universal in the sense that every well-typed expression
is executable on every supported machine architecture. Nikola is the first
programming language we have witnessed to explicitly encode term portability in
the type system. However, the ability to specialise expressions to targets
doesn't extend into the lower layers of Nikola, so as such the \texttt{t} type
variable only clutters up type signatures currently.

\paragraph{Arrays in Nikola} are modeled by the type \texttt{Array r sh a}, an associated
type of the typeclass \texttt{IsArray r a}. Arrays are parametrised on their
representation and shape by the type variables \texttt{r} and \texttt{sh},
following in the tradition of Repa. The only common operation for all arrays is
that of extracting their shape through the function \texttt{extent}. Array
shapes are similar to those of Repa and Accelerate, denoted as instances of
typeclass \texttt{Shape sh}.

Three principal array representations are provided by Nikola: The global array,
the delayed array, and the push array, denoted respectably by the types
\texttt{G}, \texttt{PSH} and \texttt{D}. This is a source of both control and
complexity, as each representation gives rise to different features and
restrictions. The global array represents a certain manifest range of memory
cells, from which it is only referentially safe to read. Push arrays and
delayed arrays however, represent array computations rather than actual areas
of memory - only at the Nikola-Haskell border are they manifest into memory. An
important consequence of this is that terms composed of delayed and push arrays
undergo fusion by construction.

What distinguishs push arrays and delayed arrays is their perspective on the
arrays they represent. A delayed array is simply a function from indices to
values, while a push array may be viewed as a stream of index/value pairs, that
may appear in potentially any ordering.


\section{Nikola Backend Architecture}

\todo{Describe the various parts of the Nikola architecture, i.e. the role of
S.Exp, the various monads, how compilation works, what substantial parts are
missing...}
